/*!
 * @asigloo/vue-dynamic-forms v3.x.x
 * (c) 2022 Alvaro Saburido
 * @license MIT
 */
import { ref, computed, watch, defineComponent, h, toRaw, nextTick, onMounted, resolveComponent, openBlock, createElementBlock, mergeProps, withModifiers, Fragment, renderList, createBlock, withCtx, renderSlot, createCommentVNode, inject } from 'vue';

const isArray = (a) => !!a && a.constructor === Array;
const isObject$1 = (a) => !!a && a.constructor === Object;
const hasValue = (value) => value !== void 0 && value !== null && value !== "";
const removeEmpty = (obj) => Object.keys(obj).filter((k) => obj[k] != null).reduce((newObj, k) => typeof obj[k] === "object" ? { ...newObj, [k]: removeEmpty(obj[k]) } : { ...newObj, [k]: obj[k] }, {});
const deepClone = (obj) => {
  let clone, value, key;
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  clone = Array.isArray(obj) ? [] : {};
  for (key in obj) {
    value = obj[key];
    clone[key] = deepClone(value);
  }
  return clone;
};

function useInputValidation(props, emit) {
  const isPendingValidation = ref(false);
  const isRequired = computed(() => {
    return props.control.validations.some((validation) => validation.type === "required");
  });
  const requiresValidation = computed(() => {
    return props.control.validations.length > 0;
  });
  async function validate(force = false) {
    if (force || (props.control.touched || props.control.dirty) && requiresValidation.value) {
      let errors = {};
      const syncValidations = [];
      const asyncValidations = [];
      props.control.validations.forEach((element) => {
        const validation = element.validator(props.control.value);
        if (validation.constructor.name === "Promise") {
          asyncValidations.push({
            validation: element.validator,
            text: element.text
          });
        } else {
          syncValidations.push({ validation, text: element.text });
        }
      });
      if (asyncValidations.length > 0) {
        isPendingValidation.value = true;
        Promise.all(asyncValidations.map(async ({ validation, text }) => ({
          validation: await validation(props.control.value),
          text
        }))).then((errorsArr) => {
          errorsArr.forEach(({ validation, text }) => {
            const [key, value] = Object.entries(validation)[0];
            errors[key] = value ? {
              value,
              text
            } : null;
          });
          isPendingValidation.value = false;
          emit("validate", {
            name: props.control.name,
            errors,
            valid: Object.keys(removeEmpty(errors)).length === 0
          });
        });
      }
      syncValidations.forEach(({ validation, text }) => {
        if (validation) {
          const [key, value] = Object.entries(validation)[0];
          errors[key] = value ? {
            value,
            text
          } : null;
        }
      });
      emit("validate", {
        name: props.control.name,
        errors,
        valid: Object.keys(removeEmpty(errors)).length === 0
      });
    }
  }
  const errorMessages = computed(() => {
    const errors = Object.values(props.control?.errors || {});
    if (errors.length > 0) {
      return errors.map((error) => error.text);
    }
    return [];
  });
  const getValidationClasses = computed(() => {
    return [
      {
        "form-control--success": !isPendingValidation.value && requiresValidation.value && props.control.errors && props.control.valid && props.control.dirty && props.control.touched
      },
      {
        "form-control--error": !isPendingValidation.value && !props.control.valid,
        "form-control--validating": isPendingValidation.value
      }
    ];
  });
  const getCheckboxValidationClasses = computed(() => {
    return [
      {
        "checkbox-group--success": !isPendingValidation.value && requiresValidation.value && props.control.errors && props.control.valid && props.control.dirty && props.control.touched
      },
      {
        "checkbox-group--error": !isPendingValidation.value && !props.control.valid,
        "checkbox-group--validating": isPendingValidation.value
      }
    ];
  });
  const getRadioValidationClasses = computed(() => {
    return [
      {
        "radio-group--success": !isPendingValidation.value && requiresValidation.value && props.control.errors && props.control.valid && props.control.dirty && props.control.touched
      },
      {
        "radio-group--error": !isPendingValidation.value && !props.control.valid,
        "radio-group--validating": isPendingValidation.value
      }
    ];
  });
  watch(() => props.forceValidation, (value) => {
    if (value) {
      validate(value);
    }
  });
  return {
    isPendingValidation,
    validate,
    getValidationClasses,
    getCheckboxValidationClasses,
    getRadioValidationClasses,
    isRequired,
    requiresValidation,
    errorMessages
  };
}

var ValidationTriggerTypes;
(function(ValidationTriggerTypes2) {
  ValidationTriggerTypes2["BLUR"] = "blur";
  ValidationTriggerTypes2["CHANGE"] = "change";
})(ValidationTriggerTypes || (ValidationTriggerTypes = {}));
var FieldTypes;
(function(FieldTypes2) {
  FieldTypes2["TEXT"] = "text";
  FieldTypes2["TEXTAREA"] = "textarea";
  FieldTypes2["SELECT"] = "select";
  FieldTypes2["NUMBER"] = "number";
  FieldTypes2["EMAIL"] = "email";
  FieldTypes2["URL"] = "url";
  FieldTypes2["PASSWORD"] = "password";
  FieldTypes2["CHECKBOX"] = "checkbox";
  FieldTypes2["RADIO"] = "radio";
  FieldTypes2["CUSTOM"] = "custom-field";
  FieldTypes2["COLOR"] = "color";
})(FieldTypes || (FieldTypes = {}));

function useInputEvents(props, emit) {
  const {
    validate,
    getValidationClasses,
    getCheckboxValidationClasses,
    getRadioValidationClasses
  } = useInputValidation(props, emit);
  function onInput($event) {
    const element = $event.target;
    $event.stopImmediatePropagation();
    if (props.control && hasValue(element.value)) {
      if (!props.control.valid && props.control.validationTrigger.type === ValidationTriggerTypes.BLUR || props.control.validationTrigger.type === ValidationTriggerTypes.CHANGE && element.value.length >= props.control.validationTrigger.threshold) {
        validate();
      }
      emit("change", {
        name: props.control.name,
        value: element.value
      });
    }
  }
  function onChange($event) {
    $event.stopImmediatePropagation();
    $event.preventDefault();
  }
  function onCheck($event) {
    const element = $event.target;
    if (props.control) {
      $event.stopImmediatePropagation();
      emit("change", {
        name: props.control.name,
        value: element.checked
      });
    }
  }
  function onFocus() {
    emit("focus", { name: props.control.name });
  }
  function onBlur() {
    emit("blur", { name: props.control.name });
    if (props.control.validationTrigger.type === ValidationTriggerTypes.BLUR) {
      validate();
    }
  }
  const getClasses = computed(() => {
    return ["form-control", ...getValidationClasses.value];
  });
  const getCheckboxClasses = computed(() => {
    return ["checkbox-group", ...getCheckboxValidationClasses.value];
  });
  const getRadioClasses = computed(() => {
    return ["radio-group", ...getRadioValidationClasses.value];
  });
  watch(() => props?.control?.value, (curr, prev) => {
    if (hasValue(curr) && curr !== prev) {
      emit("change", {
        name: props.control.name,
        value: props.control.value
      });
    }
  }, {
    immediate: true
  });
  return {
    validate,
    onFocus,
    onInput,
    onChange,
    onBlur,
    onCheck,
    getClasses,
    getCheckboxClasses,
    getRadioClasses
  };
}

const props$7 = {
  control: Object,
  forceValidation: {
    type: Boolean,
    default: false
  }
};
const _sfc_main$7 = defineComponent({
  name: "asCheckboxInput",
  inheritAttrs: false,
  props: props$7,
  setup(props2, { emit }) {
    const { onCheck, onFocus, onBlur, getCheckboxClasses } = useInputEvents(props2, emit);
    const { errorMessages, isPendingValidation, isRequired } = useInputValidation(props2, emit);
    const requiredStar = h("span", {
      ariaHidden: true,
      class: "form-required-star"
    }, " *");
    const renderCheckbox = [
      h("input", {
        name: props2.control.name || "",
        type: props2.control.type,
        id: props2.control.name,
        disabled: props2.control.disabled,
        class: "checkbox-control",
        value: props2.control.value,
        checked: props2.control.value,
        required: isRequired.value,
        readonly: props2.control.readonly,
        ariaRequired: isRequired.value,
        ariaLabel: props2.control.ariaLabel,
        ariaLabelledBy: props2.control.ariaLabelledBy,
        onFocus,
        onBlur,
        onChange: onCheck
      }),
      h("label", {
        class: ["checkbox-label"],
        for: props2.control.name
      }, [props2.control.label, isRequired.value ? requiredStar : ""])
    ];
    return () => [
      h("div", {
        class: getCheckboxClasses.value,
        tabIndex: -1,
        role: "group"
      }, renderCheckbox),
      isPendingValidation.value ? null : h("div", {
        class: "form-errors"
      }, errorMessages.value.map((error) => h("p", { class: "form-error" }, error)))
    ];
  }
});

var __glob_1_0 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: 'Module',
  'default': _sfc_main$7
});

const isDate = d => d instanceof Date;
const isEmpty = o => Object.keys(o).length === 0;
const isObject = o => o != null && typeof o === 'object';
const hasOwnProperty = (o, ...args) => Object.prototype.hasOwnProperty.call(o, ...args);
const isEmptyObject = (o) => isObject(o) && isEmpty(o);

const diff = (lhs, rhs) => {
  if (lhs === rhs) return {}; // equal return no diff

  if (!isObject(lhs) || !isObject(rhs)) return rhs; // return updated rhs

  const l = lhs;
  const r = rhs;

  const deletedValues = Object.keys(l).reduce((acc, key) => {
    if (!hasOwnProperty(r, key)) {
      acc[key] = undefined;
      
    }

    return acc;
  }, {});

  if (isDate(l) || isDate(r)) {
    if (l.valueOf() == r.valueOf()) return {};
    return r;
  }

  return Object.keys(r).reduce((acc, key) => {
    if (!hasOwnProperty(l, key)){
      acc[key] = r[key]; // return added r key
      return acc;
    } 

    const difference = diff(l[key], r[key]);

    // If the difference is empty, and the lhs is an empty object or the rhs is not an empty object
    if (isEmptyObject(difference) && !isDate(difference) && (isEmptyObject(l[key]) || !isEmptyObject(r[key])))
      return acc; // return no diff

    acc[key] = difference; // return updated key
    return acc; // return updated key
  }, deletedValues);
};

const EMPTY_CONTROL = {
  dirty: false,
  touched: false,
  valid: true,
  errors: null
};
const FieldBase = ({
  validations = [],
  label = null,
  ariaLabel = null,
  ariaLabelledBy = null,
  customClass = null,
  customStyles = null,
  disabled = false,
  placeholder = null,
  autocomplete = null,
  readonly = false,
  validationTrigger = ValidatorTrigger({
    type: ValidationTriggerTypes.BLUR,
    threshold: 0
  })
}) => ({
  validations,
  label,
  ariaLabel,
  ariaLabelledBy,
  customClass,
  customStyles,
  disabled,
  placeholder,
  autocomplete,
  readonly,
  validationTrigger
});
const TextField = ({
  value,
  ...rest
}) => ({
  ...FieldBase(rest),
  value,
  type: FieldTypes.TEXT
});
const TextAreaField = ({
  value,
  cols = 20,
  rows = 3,
  ...rest
}) => ({
  ...FieldBase(rest),
  value,
  cols,
  rows,
  type: FieldTypes.TEXTAREA
});
const EmailField = ({
  value,
  ...rest
}) => ({
  ...FieldBase(rest),
  value,
  type: FieldTypes.EMAIL
});
const PasswordField = ({
  value,
  ...rest
}) => ({
  ...FieldBase(rest),
  value,
  type: FieldTypes.PASSWORD
});
const UrlField = ({ value, ...rest }) => ({
  ...FieldBase(rest),
  value,
  type: FieldTypes.URL
});
const CheckboxField = ({
  value,
  ...rest
}) => ({
  ...FieldBase(rest),
  value,
  type: FieldTypes.CHECKBOX
});
const ColorField = ({
  value,
  ...rest
}) => ({
  ...FieldBase(rest),
  value,
  type: FieldTypes.COLOR
});
const RadioField = ({
  options,
  value,
  ...rest
}) => ({
  ...FieldBase(rest),
  value,
  options,
  type: FieldTypes.RADIO
});
const NumberField = ({
  value = null,
  min = 0,
  max = 100,
  step = 1,
  ...rest
}) => ({
  ...FieldBase(rest),
  value,
  min,
  max,
  step,
  type: FieldTypes.NUMBER
});
const SelectField = ({
  options = [],
  value,
  optionValue = "value",
  optionLabel = "label",
  ...rest
}) => ({
  ...FieldBase(rest),
  value,
  options,
  optionValue,
  optionLabel,
  type: FieldTypes.SELECT
});
const CustomField = ({
  value,
  ...rest
}) => ({
  ...FieldBase(rest),
  value,
  type: FieldTypes.CUSTOM
});
const FieldControl = ({
  name,
  type,
  ...rest
}) => ({
  ...rest,
  name,
  type,
  ...EMPTY_CONTROL
});
const Validator = ({
  validator,
  text
}) => ({
  type: validator(void 0) ? Object.keys(validator(void 0))[0] : "pattern",
  validator,
  text
});
const ValidatorTrigger = ({
  type,
  threshold
}) => ({
  type,
  threshold
});

function createFilterWrapper(filter, fn) {
  function wrapper(...args) {
    filter(() => fn.apply(this, args), { fn, thisArg: this, args });
  }
  return wrapper;
}
const bypassFilter = (invoke) => {
  return invoke();
};
function debounceFilter(ms) {
  if (ms <= 0)
    return bypassFilter;
  let timer;
  const filter = (invoke) => {
    if (timer)
      clearTimeout(timer);
    timer = setTimeout(invoke, ms);
  };
  return filter;
}
function useDebounceFn(fn, ms = 200) {
  return createFilterWrapper(debounceFilter(ms), fn);
}

function useDynamicForm(form, ctx, options) {
  let cache = deepClone(toRaw(form.fields));
  const controls = ref([]);
  const formOptions = ref({
    resetAfterSubmit: true,
    ...options?.form,
    ...form?.options
  });
  const forceValidation = ref(false);
  const deNormalizedScopedSlots = computed(() => Object.keys(ctx.slots));
  const normalizedControls = computed(() => {
    const normalizedControls2 = {};
    controls.value.forEach((element) => {
      normalizedControls2[element.name] = element;
    });
    return normalizedControls2;
  });
  const isValid = computed(() => {
    const hasInvalidControls = controls.value.some((control) => !control.valid);
    return !hasInvalidControls;
  });
  const formValues = computed(() => {
    return removeEmpty(controls.value.reduce((prev, curr) => {
      const obj = {};
      obj[curr.name] = curr.type === FieldTypes.NUMBER ? parseFloat(`${curr.value}`) : curr.value;
      return {
        ...prev,
        ...obj
      };
    }, {}));
  });
  const errors = computed(() => {
    return controls.value ? controls.value.reduce((prev, curr) => {
      const errors2 = Object.keys(curr.errors || {}) || [];
      if (errors2.length > 0) {
        const error = {};
        error[curr.name] = curr.errors;
        return {
          ...prev,
          ...error
        };
      }
      return prev;
    }, {}) : {};
  });
  const formattedOptions = computed(() => {
    const opts = formOptions.value;
    if (opts) {
      const {
        customClass,
        customStyles,
        method,
        netlify,
        netlifyHoneypot,
        autocomplete
      } = opts;
      return {
        class: customClass,
        style: customStyles,
        method,
        "data-netlify": netlify,
        "data-netlify-honeypot": netlifyHoneypot,
        autocomplete: autocomplete ? "on" : "off"
      };
    } else {
      return;
    }
  });
  function mapControls(empty = false) {
    const controlArray = Object.entries(form?.fields).map(([key, field]) => empty ? FieldControl({
      ...field,
      name: key,
      value: field.type === FieldTypes.CHECKBOX ? false : null
    }) : FieldControl({
      ...field,
      name: key
    })) || [];
    if (form.fieldOrder) {
      controls.value = controlArray.sort((a, b) => form.fieldOrder.indexOf(a.name) - form.fieldOrder.indexOf(b.name));
    } else {
      controls.value = controlArray;
    }
    if (empty) {
      debounceEmitChanges(formValues.value);
    }
  }
  function findControlByName(name) {
    const updatedCtrl = controls.value.find((control) => control.name === name);
    return updatedCtrl;
  }
  function emitChanges(changes) {
    ctx.emit("change", changes);
  }
  const debounceEmitChanges = useDebounceFn(emitChanges, 300);
  function valueChange(event) {
    if (hasValue(event.value)) {
      const updatedCtrl = findControlByName(event.name);
      if (updatedCtrl) {
        updatedCtrl.value = event.value;
        updatedCtrl.dirty = true;
      }
      debounceEmitChanges(formValues.value);
    }
  }
  function onBlur({ name }) {
    const updatedCtrl = findControlByName(name);
    if (updatedCtrl) {
      updatedCtrl.touched = true;
    }
  }
  function onValidate({ name, errors: errors2, valid }) {
    const updatedCtrl = findControlByName(name);
    if (updatedCtrl) {
      updatedCtrl.errors = removeEmpty({
        ...updatedCtrl.errors,
        ...errors2
      });
      updatedCtrl.valid = valid;
    }
  }
  function detectChanges(fields) {
    const changes = diff(cache, deepClone(fields));
    Object.entries(changes).forEach(([key, value]) => {
      const ctrl = findControlByName(key);
      if (ctrl) {
        Object.entries(value).forEach(([change, newValue]) => {
          if (change === "options" || change === "validations") {
            Object.entries(newValue).forEach(([optKey, optValue]) => {
              ctrl[change][optKey] = {
                ...ctrl[change][optKey],
                ...optValue
              };
            });
          } else {
            ctrl[change] = newValue;
          }
        });
      }
    });
    cache = deepClone(toRaw(fields));
  }
  function onOptionsChanged(changes) {
    Object.assign(formOptions.value, changes);
  }
  function resetForm() {
    mapControls(true);
    forceValidation.value = false;
  }
  async function handleSubmit() {
    validateAll();
    await nextTick();
    if (isValid.value) {
      ctx.emit("submitted", formValues.value);
      if (formOptions.value.resetAfterSubmit) {
        resetForm();
      }
    } else {
      ctx.emit("error", errors.value);
    }
  }
  function validateAll() {
    forceValidation.value = true;
  }
  onMounted(() => {
    mapControls();
  });
  return {
    controls,
    mapControls,
    valueChange,
    formValues,
    formOptions,
    handleSubmit,
    isValid,
    errors,
    deNormalizedScopedSlots,
    normalizedControls,
    formattedOptions,
    onBlur,
    onValidate,
    forceValidation,
    validateAll,
    findControlByName,
    resetForm,
    detectChanges,
    onOptionsChanged
  };
}

var _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};

const props$6 = {
  form: {
    type: Object,
    required: true
  }
};
const _sfc_main$6 = defineComponent({
  name: "asDynamicForm",
  props: props$6,
  setup(props2, ctx) {
    const { options } = useDynamicForms();
    const {
      controls,
      valueChange,
      formValues,
      handleSubmit,
      isValid,
      errors,
      deNormalizedScopedSlots,
      normalizedControls,
      formattedOptions,
      onBlur,
      onValidate,
      forceValidation,
      detectChanges,
      onOptionsChanged,
      validateAll,
      resetForm
    } = useDynamicForm(props2.form, ctx, options || {});
    watch(() => props2.form.fields, (fields) => {
      detectChanges(fields);
    }, {
      deep: true
    });
    watch(() => props2.form.fields, (options2) => {
      onOptionsChanged(options2);
    }, {
      deep: true
    });
    return {
      controls,
      valueChange,
      formValues,
      handleSubmit,
      isValid,
      errors,
      deNormalizedScopedSlots,
      normalizedControls,
      formattedOptions,
      onBlur,
      onValidate,
      forceValidation,
      validateAll,
      resetForm
    };
  }
});
const _hoisted_1 = ["id", "name"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_dynamic_input = resolveComponent("dynamic-input");
  return openBlock(), createElementBlock("form", mergeProps({
    class: "dynamic-form",
    novalidate: "",
    id: _ctx.form.id,
    name: _ctx.form.id
  }, _ctx.formattedOptions, {
    onSubmit: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.handleSubmit && _ctx.handleSubmit(...args), ["prevent"]))
  }), [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.controls, (control) => {
      return openBlock(), createBlock(_component_dynamic_input, {
        key: control.name,
        control,
        forceValidation: _ctx.forceValidation,
        onChange: _ctx.valueChange,
        onBlur: _ctx.onBlur,
        onValidate: _ctx.onValidate
      }, {
        customField: withCtx((props2) => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.deNormalizedScopedSlots, (slot) => {
            return openBlock(), createElementBlock("div", {
              key: slot,
              class: "custom-form-wrapper"
            }, [
              props2.control.name === slot ? renderSlot(_ctx.$slots, slot, {
                key: 0,
                control: _ctx.normalizedControls[slot],
                onChange: props2.onChange,
                onBlur: props2.onBlur
              }) : createCommentVNode("", true)
            ]);
          }), 128))
        ]),
        _: 2
      }, 1032, ["control", "forceValidation", "onChange", "onBlur", "onValidate"]);
    }), 128))
  ], 16, _hoisted_1);
}
var DynamicForm = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render]]);

var __glob_1_1 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: 'Module',
  'default': DynamicForm
});

const props$5 = {
  control: Object,
  forceValidation: {
    type: Boolean,
    default: false
  }
};
const _sfc_main$5 = defineComponent({
  name: "asTextInput",
  inheritAttrs: false,
  props: props$5,
  setup(props2, { emit }) {
    const { onInput, onChange, onFocus, onBlur, getClasses } = useInputEvents(props2, emit);
    const { isRequired, errorMessages, isPendingValidation } = useInputValidation(props2, emit);
    return () => [
      h("input", {
        id: props2.control.name,
        name: props2.control.name || "",
        type: props2.control.type,
        class: getClasses.value,
        value: props2.control.value,
        disabled: props2.control.disabled,
        placeholder: props2.control.placeholder,
        required: isRequired.value,
        readonly: props2.control.readonly,
        autocomplete: props2.control.autocomplete,
        ariaRequired: isRequired.value,
        ariaLabel: props2.control.ariaLabel,
        ariaLabelledBy: props2.control.ariaLabelledBy,
        onFocus,
        onBlur,
        onInput,
        onChange
      }),
      isPendingValidation.value ? null : h("div", {
        class: "form-errors"
      }, errorMessages.value.map((error) => h("p", { class: "form-error" }, error)))
    ];
  }
});

var __glob_1_7 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: 'Module',
  'default': _sfc_main$5
});

const props$4 = {
  control: Object,
  forceValidation: {
    type: Boolean,
    default: false
  }
};
const _sfc_main$4 = defineComponent({
  name: "asSelectInput",
  inheritAttrs: false,
  props: props$4,
  setup(props2, { emit }) {
    return () => {
      const { onInput, onChange, onFocus, onBlur, getClasses } = useInputEvents(props2, emit);
      const { isRequired, errorMessages, isPendingValidation } = useInputValidation(props2, emit);
      const formattedOptions = computed(() => {
        if (isObject$1(props2?.control?.options)) {
          return Object.values(props2?.control?.options);
        }
        return props2?.control?.options;
      });
      const options = formattedOptions?.value?.map((option) => h("option", {
        key: option[props2.control.optionValue],
        value: option[props2.control.optionValue],
        disabled: option.disabled
      }, option[props2.control.optionLabel]));
      return [
        h("select", {
          id: props2.control.name,
          name: props2.control.name || "",
          class: getClasses.value,
          value: props2.control.value,
          disabled: props2.control.disabled,
          placeholder: props2.control.placeholder,
          required: isRequired.value,
          readonly: props2.control.readonly,
          ariaLabel: props2.control.ariaLabel,
          ariaLabelledBy: props2.control.ariaLabelledBy,
          ariaRequired: isRequired.value,
          onFocus,
          onBlur,
          onInput,
          onChange
        }, options),
        isPendingValidation.value ? null : h("div", {
          class: "form-errors"
        }, errorMessages.value.map((error) => h("p", { class: "form-error" }, error)))
      ];
    };
  }
});

var __glob_1_5 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: 'Module',
  'default': _sfc_main$4
});

const props$3 = {
  control: Object,
  forceValidation: {
    type: Boolean,
    default: false
  }
};
const _sfc_main$3 = defineComponent({
  name: "asTextAreaInput",
  inheritAttrs: false,
  props: props$3,
  setup(props2, { emit }) {
    const { onInput, onChange, onFocus, onBlur, getClasses } = useInputEvents(props2, emit);
    const { isRequired, errorMessages, isPendingValidation } = useInputValidation(props2, emit);
    return () => [
      h("textarea", {
        id: props2.control.name,
        name: props2.control.name || "",
        class: getClasses.value,
        value: props2.control.value,
        rows: props2.control.rows,
        cols: props2.control.cols,
        disabled: props2.control.disabled,
        placeholder: props2.control.placeholder,
        required: isRequired.value,
        autocomplete: props2.control.autocomplete,
        readonly: props2.control.readonly,
        ariaLabel: props2.control.ariaLabel,
        ariaLabelledBy: props2.control.ariaLabelledBy,
        ariaRequired: isRequired.value,
        onFocus,
        onBlur,
        onInput,
        onChange
      }),
      isPendingValidation.value ? null : h("div", {
        class: "form-errors"
      }, errorMessages.value.map((error) => h("p", { class: "form-error" }, error)))
    ];
  }
});

var __glob_1_6 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: 'Module',
  'default': _sfc_main$3
});

const props$2 = {
  control: Object,
  forceValidation: {
    type: Boolean,
    default: false
  }
};
const _sfc_main$2 = defineComponent({
  name: "asRadioInput",
  inheritAttrs: false,
  props: props$2,
  setup(props2, { emit }) {
    const { onCheck, onInput, onFocus, onBlur, getRadioClasses } = useInputEvents(props2, emit);
    const { errorMessages, isPendingValidation } = useInputValidation(props2, emit);
    const renderRadios = props2?.control?.options?.map((option) => {
      return h("div", { class: "radio-input" }, [
        h("input", {
          name: props2?.control?.name || "",
          type: props2?.control?.type,
          id: option.key,
          disabled: option.disabled || props2?.control?.disabled,
          checked: props2.control.value === option.key,
          class: ["radio-control"],
          value: option.key,
          onFocus,
          onBlur,
          onInput,
          onCheck
        }),
        h("label", {
          class: ["radio-label"],
          for: option.key
        }, option.value)
      ]);
    });
    return () => [
      h("div", {
        class: getRadioClasses.value,
        tabIndex: -1,
        role: "group"
      }, renderRadios),
      isPendingValidation.value ? null : h("div", {
        class: "form-errors"
      }, errorMessages.value.map((error) => h("p", { class: "form-error" }, error)))
    ];
  }
});

var __glob_1_4 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: 'Module',
  'default': _sfc_main$2
});

const props$1 = {
  control: Object,
  forceValidation: {
    type: Boolean,
    default: false
  }
};
const _sfc_main$1 = defineComponent({
  name: "asNumberInput",
  inheritAttrs: false,
  props: props$1,
  setup(props2, { emit }) {
    const { onInput, onChange, onFocus, onBlur, getClasses } = useInputEvents(props2, emit);
    const { isRequired, errorMessages, isPendingValidation } = useInputValidation(props2, emit);
    return () => [
      h("input", {
        id: props2.control.name,
        name: props2.control.name || "",
        type: props2.control.type,
        class: getClasses.value,
        value: props2.control.value,
        min: props2.control.min,
        max: props2.control.max,
        step: props2.control.step,
        disabled: props2.control.disabled,
        placeholder: props2.control.placeholder,
        required: isRequired.value,
        readonly: props2.control.readonly,
        autocomplete: props2.control.autocomplete,
        ariaLabel: props2.control.ariaLabel,
        ariaLabelledBy: props2.control.ariaLabelledBy,
        ariaRequired: isRequired.value,
        onFocus,
        onBlur,
        onInput,
        onChange
      }),
      isPendingValidation.value ? null : h("div", {
        class: "form-errors"
      }, errorMessages.value.map((error) => h("p", { class: "form-error" }, error)))
    ];
  }
});

var __glob_1_3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: 'Module',
  'default': _sfc_main$1
});

const components$1 = {
  TextInputComponent: _sfc_main$5,
  SelectInputComponent: _sfc_main$4,
  TextAreaInputComponent: _sfc_main$3,
  CheckboxInputComponent: _sfc_main$7,
  RadioInputComponent: _sfc_main$2,
  NumberInputComponent: _sfc_main$1
};
const props = {
  control: {
    type: Object,
    required: true
  },
  forceValidation: {
    type: Boolean,
    default: false
  }
};
const _sfc_main = defineComponent({
  name: "asDynamicInput",
  components: components$1,
  inheritAttrs: false,
  props,
  setup(props2, { emit, slots }) {
    const { onFocus, onInput, onBlur } = useInputEvents(props2, emit);
    let component;
    const attributes = computed(() => {
      return {
        control: props2?.control,
        onChange: valueChange,
        onBlur: (e) => emit("blur", e),
        onFocus: (e) => emit("focus", e),
        onValidate: (validation) => emit("validate", validation),
        forceValidation: props2.forceValidation
      };
    });
    const hasLabel = computed(() => props2?.control?.label && props2?.control?.type !== "checkbox");
    const isFieldSet = computed(() => props2?.control?.type === "radio");
    const getClasses = computed(() => {
      const classes = [
        "dynamic-input",
        "form-group",
        {
          "form-group--inline": props2?.control?.type === FieldTypes.CHECKBOX
        }
      ];
      if (isArray(props2?.control?.customClass)) {
        return [
          ...classes,
          ...props2?.control?.customClass
        ];
      }
      if (isObject$1(props2?.control?.customClass)) {
        return [...classes, props2?.control?.customClass];
      }
      return [classes, props2?.control?.customClass];
    });
    function valueChange(event) {
      emit("change", event);
    }
    return () => {
      switch (props2?.control?.type) {
        case FieldTypes?.TEXT:
          component = h(_sfc_main$5, attributes.value);
          break;
        case "email":
          component = h(_sfc_main$5, attributes.value);
          break;
        case "password":
          component = h(_sfc_main$5, attributes.value);
          break;
        case "url":
          component = h(_sfc_main$5, attributes.value);
          break;
        case "color":
          component = h(_sfc_main$5, attributes.value);
          break;
        case "number":
          component = h(_sfc_main$1, attributes.value);
          break;
        case "select":
          component = h(_sfc_main$4, attributes.value);
          break;
        case "textarea":
          component = h(_sfc_main$3, attributes.value);
          break;
        case "checkbox":
          component = h(_sfc_main$7, attributes.value);
          break;
        case "radio":
          component = h(_sfc_main$2, attributes.value);
          break;
        case "custom-field":
          component = h("slot", {
            name: "customField"
          }, slots.customField({
            control: props2.control,
            onChange: onInput,
            onFocus,
            onBlur
          }));
          break;
      }
      const requiredStar = h("span", {
        ariaHidden: true,
        class: "form-required-star"
      }, " *");
      return h(isFieldSet.value ? "fieldset" : "div", {
        class: getClasses.value,
        style: props2?.control.customStyles,
        role: isFieldSet.value ? void 0 : "group"
      }, [
        hasLabel.value ? h(isFieldSet.value ? "legend" : "label", {
          class: "form-label",
          for: props2?.control?.name
        }, [
          `${props2?.control?.label}`,
          props2?.control?.validations?.some((validator) => validator.type === "required") ? requiredStar : ""
        ]) : null,
        component
      ]);
    };
  }
});

var __glob_1_2 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  [Symbol.toStringTag]: 'Module',
  'default': _sfc_main
});

const components = { "./components/checkbox-input/CheckboxInput.vue": __glob_1_0, "./components/dynamic-form/DynamicForm.vue": __glob_1_1, "./components/dynamic-input/DynamicInput.vue": __glob_1_2, "./components/number-input/NumberInput.vue": __glob_1_3, "./components/radio-input/RadioInput.vue": __glob_1_4, "./components/select-input/SelectInput.vue": __glob_1_5, "./components/text-area-input/TextAreaInput.vue": __glob_1_6, "./components/text-input/TextInput.vue": __glob_1_7,};
const dynamicFormsSymbol = Symbol("vdf");
function useDynamicForms() {
  const dynamicForms = inject(dynamicFormsSymbol);
  if (!dynamicForms)
    throw new Error("No dynamicForms provided!!!");
  return dynamicForms;
}
function createDynamicForms(options) {
  const $vdf = {
    options,
    install(app) {
      app.provide(dynamicFormsSymbol, $vdf);
      Object.entries(components).forEach(([path, definition]) => {
        const componentName = path.split("/").pop().replace(/\.\w+$/, "");
        app.component(componentName, definition.default);
      });
      Object.defineProperty(app, "__VUE_DYNAMIC_FORMS_SYMBOL__", {
        get() {
          return dynamicFormsSymbol;
        }
      });
    }
  };
  return $vdf;
}

const isEmptyInputValue = (value) => value == null || value === "";
const EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;
const URL_REGEXP = /^((?:(https?):\/\/)?((?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]|[0-9])\.(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]|[0-9])\.)(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]|[0-9])\.)(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[0-9][0-9]|[0-9]))|(?:(?:(?:\w+\.){1,2}[\w]{2,3})))(?::(\d+))?((?:\/[\w]+)*)(?:\/|(\/[\w]+\.[\w]{3,4})|(\?(?:([\w]+=[\w]+)&)*([\w]+=[\w]+))?|\?(?:(wsdl|wadl))))$/;
const required = (value) => ({
  required: isEmptyInputValue(value) ? true : null
});
const min = (min2) => (value) => {
  if (isEmptyInputValue(value) || isEmptyInputValue(min2)) {
    return { min: null };
  }
  const minValue = parseFloat(`${value}`);
  return {
    min: !isNaN(minValue) && minValue < min2 ? { min: min2, actual: +minValue } : null
  };
};
const max = (max2) => (value) => {
  if (isEmptyInputValue(value) || isEmptyInputValue(max2)) {
    return { max: null };
  }
  const maxValue = parseFloat(`${value}`);
  return {
    max: !isNaN(maxValue) && maxValue > max2 ? { max: max2, actual: +maxValue } : null
  };
};
const email = (value) => {
  if (isEmptyInputValue(value)) {
    return { email: null };
  }
  return { email: EMAIL_REGEXP.test(`${value}`) ? null : true };
};
const url = (value) => {
  if (isEmptyInputValue(value)) {
    return { url: null };
  }
  return { url: URL_REGEXP.test(`${value}`) ? null : true };
};
const minLength = (minLength2) => (value) => {
  if (isEmptyInputValue(value)) {
    return { minLength: null };
  }
  const length = value ? `${value}`.length : 0;
  return {
    minLength: length < minLength2 ? { requiredLength: minLength2, actualLength: length } : null
  };
};
const maxLength = (maxLength2) => (value) => {
  if (isEmptyInputValue(value)) {
    return { maxLength: null };
  }
  const length = value ? `${value}`.length : 0;
  return {
    maxLength: length > maxLength2 ? { requiredLength: maxLength2, actualLength: length } : null
  };
};
const pattern = (pattern2) => {
  if (!pattern2)
    return null;
  let regex;
  let regexStr;
  if (typeof pattern2 === "string") {
    regexStr = "";
    if (pattern2.charAt(0) !== "^")
      regexStr += "^";
    regexStr += pattern2;
    if (pattern2.charAt(pattern2.length - 1) !== "$")
      regexStr += "$";
    regex = new RegExp(regexStr);
  } else {
    regexStr = pattern2;
    regex = pattern2;
  }
  return (value) => {
    if (isEmptyInputValue(value)) {
      return { pattern: null };
    }
    const patternValue = value;
    return {
      pattern: regex.test(patternValue) ? null : { requiredPattern: regexStr, actualValue: value }
    };
  };
};

export { CheckboxField, ColorField, CustomField, EmailField, FieldBase, FieldControl, FieldTypes, NumberField, PasswordField, RadioField, SelectField, TextAreaField, TextField, UrlField, ValidationTriggerTypes, Validator, ValidatorTrigger, createDynamicForms, dynamicFormsSymbol, email, isEmptyInputValue, max, maxLength, min, minLength, pattern, required, url, useDynamicForms };
/* follow me on Twitter! @alvaro_code */
